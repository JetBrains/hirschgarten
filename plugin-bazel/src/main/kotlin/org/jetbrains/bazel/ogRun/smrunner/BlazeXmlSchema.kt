/*
 * Copyright 2016 The Bazel Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jetbrains.bazel.ogRun.smrunner

import com.google.common.collect.Lists
import java.io.InputStream
import java.util.Objects
import java.util.stream.Collectors
import javax.xml.bind.JAXBContext
import javax.xml.bind.JAXBException
import javax.xml.bind.annotation.XmlAnyElement
import javax.xml.bind.annotation.XmlAttribute
import javax.xml.bind.annotation.XmlElement
import javax.xml.bind.annotation.XmlMixed
import javax.xml.bind.annotation.XmlRootElement

/** Used to parse the test.xml generated by the blaze/bazel testing framework.  */
object BlazeXmlSchema {
  private val CONTEXT: JAXBContext

  init {
    try {
      CONTEXT = JAXBContext.newInstance(TestSuite::class.java, TestSuites::class.java)
    } catch (e: JAXBException) {
      throw RuntimeException(e)
    }
  }

  @JvmStatic
  fun parse(input: InputStream?): TestSuite? {
    try {
      val parsed = CONTEXT.createUnmarshaller().unmarshal(input)
      return if (parsed is TestSuites) {
        parsed.convertToTestSuite()
      } else {
        parsed as TestSuite?
      }
    } catch (e: JAXBException) {
      throw RuntimeException("Failed to parse test XML", e)
    }
  }

  /** Used to merge test suites from a single target, split across multiple shards  */
  fun mergeSuites(suites: MutableList<TestSuite>): TestSuite {
    val outer = TestSuite()
    for (suite in suites) {
      outer.addSuite(suite)
    }
    return outer
  }

  @JvmStatic
  fun getErrorContent(err: ErrorOrFailureOrSkipped): String? {
    if (err.content == null) {
      return null
    }
    return err.content
      .stream()
      .filter { obj: Any? -> Objects.nonNull(obj) }
      .map<String?> { obj: Any? -> obj.toString() }
      .map<String?> { obj: String? -> obj!!.trim { it <= ' ' } }
      .filter { s: String? -> !s!!.isEmpty() }
      .collect(Collectors.joining("\n"))
  }

  // optional wrapping XML element. Some test runners don't include it.
  @XmlRootElement(name = "testsuites")
  internal class TestSuites {
    @XmlElement(name = "testsuite")
    var testSuites: MutableList<TestSuite?> = Lists.newArrayList<TestSuite?>()

    fun convertToTestSuite(): TestSuite {
      val suite = TestSuite()
      suite.testSuites.addAll(testSuites)
      return suite
    }
  }

  /** XML output by blaze test runners.  */
  @XmlRootElement(name = "testsuite")
  class TestSuite {
    @JvmField
    @XmlAttribute
    var name: String? = null

    @XmlAttribute
    var classname: String? = null

    @XmlAttribute
    var tests: Int = 0

    @XmlAttribute
    var failures: Int = 0

    @XmlAttribute
    var errors: Int = 0

    @XmlAttribute
    var skipped: Int = 0

    @XmlAttribute
    var disabled: Int = 0

    @XmlAttribute
    var time: Double = 0.0

    @JvmField
    @XmlElement(name = "system-out")
    var sysOut: String? = null

    @JvmField
    @XmlElement(name = "system-err")
    var sysErr: String? = null

    @XmlElement(name = "error", type = ErrorOrFailureOrSkipped::class)
    var error: ErrorOrFailureOrSkipped? = null

    @XmlElement(name = "failure", type = ErrorOrFailureOrSkipped::class)
    var failure: ErrorOrFailureOrSkipped? = null

    @JvmField
    @XmlElement(name = "testsuite")
    var testSuites: MutableList<TestSuite> = Lists.newArrayList<TestSuite?>()

    @JvmField
    @XmlElement(name = "testdecorator")
    var testDecorators: MutableList<TestSuite?> = Lists.newArrayList<TestSuite?>()

    @JvmField
    @XmlElement(name = "testcase")
    var testCases: MutableList<TestCase?> = Lists.newArrayList<TestCase?>()

    /** Used to merge test suites from a single target, split across multiple shards  */
    private fun addSuite(suite: TestSuite) {
      for (existing in testSuites) {
        if (existing.name == suite.name) {
          existing.mergeWithSuite(suite)
          return
        }
      }
      testSuites.add(suite)
    }

    private fun mergeWithSuite(suite: TestSuite) {
      for (child in suite.testSuites) {
        addSuite(child)
      }
      testDecorators.addAll(suite.testDecorators)
      testCases.addAll(suite.testCases)
      tests += suite.tests
      failures += suite.failures
      errors += suite.errors
      skipped += suite.skipped
      disabled += suite.disabled
      time += suite.time
    }
  }

  /** Individual test case XML output by blaze test runners.  */
  class TestCase {
    @JvmField
    @XmlAttribute
    var name: String? = null

    @JvmField
    @XmlAttribute
    var classname: String? = null

    @JvmField
    @XmlAttribute
    var status: String? = null

    @JvmField
    @XmlAttribute
    var result: String? = null

    @JvmField
    @XmlAttribute
    var time: String? = null

    @JvmField
    @XmlElement(name = "system-out")
    var sysOut: String? = null

    @JvmField
    @XmlElement(name = "system-err")
    var sysErr: String? = null

    @JvmField
    @XmlElement(name = "error", type = ErrorOrFailureOrSkipped::class)
    var errors: MutableList<ErrorOrFailureOrSkipped?> = Lists.newArrayList<ErrorOrFailureOrSkipped?>()

    @JvmField
    @XmlElement(name = "failure", type = ErrorOrFailureOrSkipped::class)
    var failures: MutableList<ErrorOrFailureOrSkipped?> = Lists.newArrayList<ErrorOrFailureOrSkipped?>()

    @JvmField
    @XmlElement(name = "skipped", type = ErrorOrFailureOrSkipped::class)
    var skipped: ErrorOrFailureOrSkipped? = null
  }

  internal class ErrorOrFailureOrSkipped {
    // Can't use @XmlValue with @XmlElement
    @XmlMixed
    @XmlAnyElement(lax = true)
    private val content: MutableList<Any?>? = null

    @JvmField
    @XmlAttribute
    var message: String? = null

    @XmlAttribute
    var type: String? = null

    @JvmField
    @XmlElement(name = "expected", type = Values::class)
    var expected: Values? = null

    @JvmField
    @XmlElement(name = "actual", type = Values::class)
    var actual: Values? = null
  }

  internal class Values {
    @JvmField
    @XmlElement(name = "value", type = String::class)
    var values: MutableList<String?> = ArrayList<String?>()
  }
}
