#if( $javaEnabled == "true" && $bazel8OrAbove == "true" && $rulesetName != "" )
load("@${rulesetName}//java/common:java_common.bzl", "java_common")
load("@${rulesetName}//java/common:java_info.bzl", "JavaInfo")
load("@${rulesetName}//java/common:java_plugin_info.bzl", "JavaPluginInfo")
load("@${rulesetName}//java:java_utils.bzl", java_utils = "utils")
#end

load("//${bspPath}/aspects:utils/utils.bzl", "create_struct", "to_file_location", "BspAspectInfo", "file_location", "is_external", "IMPORT_RULE_KIND", "update_sync_output_groups", "map_with_resolve_files", "map")
load("//${bspPath}/aspects:utils/jvm_common.bzl", "to_generated_jvm_outputs", "get_generated_jars", "provider_resolve_depsets", "to_jvm_outputs")
load("//${bspPath}/aspects:utils/make_variables.bzl", "expand_make_variables")


def java_info_in_target(target):
    #if( $javaEnabled == "true" )
    return JavaInfo in target

    #else
    return False
    #end

def get_java_info(target):
    #if( $javaEnabled == "true" )
    if JavaInfo in target:
        return target[JavaInfo]
    else:
        return None

    #else
    return None
    #end

def _get_javacopts_from_context(ctx):
    javacopts_raw = getattr(ctx.rule.attr, "javacopts", [])
    if javacopts_raw == None: # "javacopts" might exist in ctx.rule.attr as None
        javacopts_raw = []
    javacopts = expand_make_variables(ctx, True, javacopts_raw)
    add_exports = ["--add-exports=" + export + "=ALL-UNNAMED" for export in getattr(ctx.rule.attr, "add_exports", [])]
    add_opens = ["--add-opens=" + open + "=ALL-UNNAMED" for open in getattr(ctx.rule.attr, "add_opens", [])]
    return javacopts + add_exports + add_opens

def get_javacopts(target, ctx):
    #if( $javaEnabled == "true" && $bazel8OrAbove == "true" && $rulesetName != "" )
    java_info = get_java_info(target)
    if java_info != None:
        compilation_info = getattr(java_info, "compilation_info", None)
        module_flags_info = getattr(java_info, "module_flags_info", None)
        if compilation_info != None and module_flags_info != None:
            javacopts = java_utils.tokenize_javacopts(ctx, compilation_info.javac_options)
            # javacopts here contain --add-export flags already (https://github.com/bazelbuild/rules_java/blob/faaab4062f81deefaeef76dd21b2a5212432f8e3/java/private/java_common_internal.bzl#L159)
            add_opens = ["--add-opens=" + open + "=ALL-UNNAMED" for open in module_flags_info.add_opens.to_list()]
            return javacopts + add_opens
    return _get_javacopts_from_context(ctx)

    #else
    return _get_javacopts_from_context(ctx)
    #end

def get_java_plugin_info(target):
    #if( $javaEnabled == "true" )
    if JavaPluginInfo in target:
        return target[JavaPluginInfo]
    else:
        return None

    #else
    return None
    #end

def extract_java_toolchain(target, ctx, dep_targets, **kwargs):
    toolchain = None
    if java_common.JavaToolchainInfo != platform_common.ToolchainInfo and java_common.JavaToolchainInfo in target:
        toolchain = target[java_common.JavaToolchainInfo]

    toolchain_info = None
    if toolchain != None:
        java_home = to_file_location(toolchain.java_runtime.java_home, "", False, True) if hasattr(toolchain, "java_runtime") else None

        # See https://github.com/bazelbuild/rules_java/commit/449303e723185a8197794c42711602e66b1a9296#diff-fe0bb6824aba3c40e5f366dce11a17b53e7e8fefb12c94afe652f480fd05cd00
        _system_path = getattr(getattr(toolchain, "_bootclasspath_info", None), "_system_path", None)
        boot_classpath_java_home = to_file_location(_system_path, "", False, True) if _system_path else None

        toolchain_info = create_struct(
            source_version = toolchain.source_version,
            target_version = toolchain.target_version,
            java_home = java_home,
            boot_classpath_java_home = boot_classpath_java_home,
        )
    else:
        for dep in dep_targets:
            if BspAspectInfo in dep and hasattr(dep[BspAspectInfo].bsp_info, "java_toolchain_info"):
                toolchain_info = dep[BspAspectInfo].bsp_info.java_toolchain_info
                break

    if toolchain_info != None:
        result = dict(java_toolchain_info = toolchain_info)
        return result, result
    else:
        return None, None

def get_jdeps(target): 
    if java_info_in_target(target):
        return [jo.jdeps for jo in get_java_info(target).java_outputs if jo.jdeps != None]
    return []


JAVA_RUNTIME_TOOLCHAIN_TYPE = "@bazel_tools//tools/jdk:runtime_toolchain_type"

def extract_java_runtime(target, ctx, output_groups, dep_targets, **kwargs):
    runtime = None

    if JAVA_RUNTIME_TOOLCHAIN_TYPE in ctx.toolchains:
        toolchain = ctx.toolchains[JAVA_RUNTIME_TOOLCHAIN_TYPE]
        if toolchain:
            runtime = toolchain.java_runtime
    else:
        runtime_jdk = getattr(ctx.rule.attr, "runtime_jdk", None)
        if runtime_jdk and java_common.JavaRuntimeInfo in runtime_jdk:
            runtime = runtime_jdk[java_common.JavaRuntimeInfo]

    runtime_info = None
    if runtime != None:
        java_home = to_file_location(runtime.java_home, "", False, True) if hasattr(runtime, "java_home") else None
        runtime_info = create_struct(java_home = java_home)
    else:
        for dep in dep_targets:
            if BspAspectInfo in dep and hasattr(dep[BspAspectInfo].bsp_info, "java_runtime_info"):
                runtime_info = dep[BspAspectInfo].bsp_info.java_runtime_info
                break

    jdeps = get_jdeps(target)
    java_outputs = []
    provider = get_java_info(target)
    if provider:
        if hasattr(provider, "java_outputs") and provider.java_outputs:
            java_outputs = provider.java_outputs
        elif hasattr(provider, "outputs") and provider.outputs:
            java_outputs = provider.outputs.jars
    jars, resolve_files_jars = map_with_resolve_files(to_jvm_outputs, java_outputs)
    generated_jars, resolve_files_generated_jars = get_generated_jars(provider)
    
    resolve_files = resolve_files_jars + resolve_files_generated_jars
    resolve_files_transitive = []
    if is_external(target) or ctx.rule.kind in IMPORT_RULE_KIND:
        resolve_files_transitive += provider_resolve_depsets(target, provider)
        update_sync_output_groups(output_groups, "bsp-sync-artifact", depset(resolve_files, transitive=resolve_files_transitive))
    else:
        resolve_files += jdeps
        update_sync_output_groups(output_groups, "bsp-build-artifact", depset(resolve_files))


    java_common_info = dict(jdeps = [file_location(j) for j in jdeps],
                            jars = jars, generated_jars = generated_jars,
                            javac_opts = get_javacopts(target, ctx),
                       )
    info_result = dict(java_common = java_common_info)

    export_result = None
    if runtime_info != None:
        info_result["java_runtime_info"] = runtime_info
        export_result = dict(java_runtime_info = runtime_info)
    if provider:
        info_result["jvm_target"] = True
        info_result["java_provider"] = struct(
            full_compile_jars = map(file_location, getattr(provider, "full_compile_jars", depset()).to_list())
        )

    java_plugin_info = get_java_plugin_info(target)
    if java_plugin_info:
        if len(java_plugin_info.api_generating_plugins.processor_classes.to_list()) > 0:
            info_result["has_api_generating_plugins"] = True

    return info_result, export_result
