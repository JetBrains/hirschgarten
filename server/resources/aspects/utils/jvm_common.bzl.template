load("//${bspPath}/aspects:utils/utils.bzl", "file_location", "map_with_resolve_files", "filter_not_none", "map")

def to_generated_jvm_outputs(output):
    if output == None or output.generated_class_jar == None:
        return None

    class_jar = output.generated_class_jar
    source_jar = output.generated_source_jar

    output = struct(
        binary_jars = [file_location(class_jar)],
        source_jars = [file_location(source_jar)],
    )
    resolve_files = [class_jar, source_jar]
    return output, resolve_files

def get_generated_jars(provider):
    if hasattr(provider, "java_outputs"):
        return map_with_resolve_files(to_generated_jvm_outputs, provider.java_outputs)

    if hasattr(provider, "annotation_processing") and provider.annotation_processing and provider.annotation_processing.enabled:
        class_jars = filter_not_none([provider.annotation_processing.class_jar])
        source_jars = filter_not_none([provider.annotation_processing.source_jar])

        # Additional info from `rules_kotlin`'s `KtJvmInfo`
        if hasattr(provider, "additional_generated_source_jars"):
            source_jars = source_jars + [jar for jar in provider.additional_generated_source_jars]
        if hasattr(provider, "all_output_jars"):
            class_jars = class_jars + [jar for jar in provider.all_output_jars]

        output = struct(
            binary_jars = [file_location(jar) for jar in class_jars],
            source_jars = [file_location(jar) for jar in source_jars],
        )
        resolve_files = class_jars + source_jars
        return [output], resolve_files

    return [], []

def extract_runtime_jars(target, provider):
    compilation_info = getattr(provider, "compilation_info", None)
    
    if compilation_info:
        return compilation_info.runtime_classpath
        
    return getattr(provider, "transitive_runtime_jars", depset())

def extract_compile_jars(provider):
    compilation_info = getattr(provider, "compilation_info", None)

    return compilation_info.compilation_classpath if compilation_info else depset()

def get_interface_jars(output):
    if hasattr(output, "compile_jar") and output.compile_jar:
        return [output.compile_jar]
    elif hasattr(output, "ijar") and output.ijar:
        return [output.ijar]
    else:
        return []


def get_binary_jars(output):
    if hasattr(output, "class_jar") and output.class_jar:
        return [output.class_jar]
    else:
        return []

def get_source_jars(output):
    if hasattr(output, "source_jars"):
        source_jars = output.source_jars
        if type(source_jars) == "depset":
            return source_jars.to_list()
        else:
            # assuming it returns sequence type here
            return source_jars
    if hasattr(output, "source_jar") and output.source_jar != None:
        return [output.source_jar]
    return []

def to_jvm_outputs(output):
    if output == None:
        return None

    binary_jars = get_binary_jars(output)
    interface_jars = get_interface_jars(output)
    source_jars = get_source_jars(output)
    output = struct(
        binary_jars = map(file_location, binary_jars),
        interface_jars = map(file_location, interface_jars),
        source_jars = map(file_location, source_jars),
    )
    resolve_files = binary_jars + interface_jars + source_jars
    return output, resolve_files

def provider_resolve_depsets(target, provider):
    if provider:
        return [extract_runtime_jars(target, provider), extract_compile_jars(provider), getattr(provider, "transitive_source_jars", depset())]
    else:
        return []
